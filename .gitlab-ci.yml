variables:
  DOCKER_VERSION: "28.1.1"
  PYTHON_VERSION: "3.13"
  LATEST_TAG: $CI_REGISTRY_IMAGE:latest

stages:
  - build
  - test
  - deploy
  - healthcheck

build:
  stage: build
  tags:
    - docker
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"${CI_REGISTRY}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        export VERSION_TAG="$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG"
      else
        export VERSION_TAG="$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
      fi
      echo "Building image with tag: $VERSION_TAG"
      /kaniko/executor \
        --context "${CI_PROJECT_DIR}" \
        --dockerfile "${CI_PROJECT_DIR}/Dockerfile" \
        --destination "${VERSION_TAG}" \
        --destination "${LATEST_TAG}" \
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'

# Currently deactivated, because generated requirements may depend on the
# used system. We need to build the requirements with a docker container
# to ensure consistent output.
# check-requirements:
#   image: python:$PYTHON_VERSION
#   stage: test
#   tags:
#     - docker
#   script:
#     - pip install pip-tools
#     - for file in requirements*.in; do pip-compile "$file"; done
#     - git diff --exit-code
#   rules:
#     - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
#     - if: '$CI_COMMIT_BRANCH == "main"'

pylint:
  stage: test
  image: python:$PYTHON_VERSION
  variables:
    DJANGO_SECRET_KEY: "dummysecretkeyforci"
  tags:
    - docker
  before_script:
    - pip install -r requirements-dev.txt
  script:
    - pylint --output-format=json . > pylint.json
    - cat pylint.json
  artifacts:
    reports:
      codequality: pylint.json
    paths:
      - pylint.json
    expire_in: 1 week
  allow_failure: false
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'

pytest:
  stage: test
  image: python:$PYTHON_VERSION
  variables:
    DJANGO_SECRET_KEY: "dummysecretkeyforci"
    DJANGO_DEBUG: "True"
  tags:
    - docker
  before_script:
    - pip install -r requirements-dev.txt
  script:
    # Run pytest with coverage and HTML report, fail if overall coverage < 80%
    - pytest --cov=. --cov-report=term-missing --cov-report=xml --cov-report=html --cov-fail-under=80 --junitxml=report.xml --html=pytest-report.html
    # Only run diff-cover if this is a merge request (not on main or tags)
    - |
      if [ -n "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" ]; then
        git fetch origin $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
        diff-cover coverage.xml --compare-branch origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME --fail-under=95
      fi
  artifacts:
    reports:
      junit: report.xml
    paths:
      - pytest-report.html
      - htmlcov/
      - .coverage
      - coverage.xml
    expire_in: 1 week
  coverage: '/TOTAL.*?(\d+\%)$/'
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'

deploy_dev:
  stage: deploy
  image: docker:$DOCKER_VERSION
  tags:
    - docker
  before_script:
    - 'which rsync || ( apk add --no-cache rsync )'
    - 'which ssh-agent || ( apk add --no-cache openssh-client)'
    - 'which envsubst || apk add --no-cache gettext'
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | base64 -d | tr -d '\r' | ssh-add - || echo "Failed to add SSH key"
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_SERVER_DEV >> ~/.ssh/known_hosts
    - docker login $CI_REGISTRY -u "$CI_DEPLOY_USER" -p "$CI_DEPLOY_PASSWORD"
    - cp .env.example .env
    - sed -i "s|^#\?ALLOWED_HOSTS=.*|ALLOWED_HOSTS=$DEPLOY_SERVER_DEV|" .env
    - sed -i "s|^#\?CSRF_TRUSTED_ORIGINS=.*|CSRF_TRUSTED_ORIGINS=https://$DEPLOY_SERVER_DEV|" .env
    - sed -i "s|^#\?GITHUB_REPO=.*|GITHUB_REPO=$GITHUB_REPO_BACKEND_STORAGE_DEV|" .env
    - sed -i "s|^#\?GITHUB_ACCESS_TOKEN=.*|GITHUB_ACCESS_TOKEN=$GITHUB_ACCESS_TOKEN_BACKEND_STORAGE_DEV|" .env
    - sed -i "s|^#\?DJANGO_SECRET_KEY=.*|DJANGO_SECRET_KEY=\"$DJANGO_SECRET_KEY_DEV\"|" .env
    - |
      if grep -q '^DJANGO_DEBUG=' .env; then
        sed -i 's/^DJANGO_DEBUG=.*/DJANGO_DEBUG=True/' .env
      else
        echo 'DJANGO_DEBUG=True' >> .env
      fi
  script:
    - export IMAGE_TAG="$CI_COMMIT_SHORT_SHA"
    - envsubst < docker-compose-deploy-template.yml > docker-compose.yml
    - ssh $DEPLOY_USER_DEV@$DEPLOY_SERVER_DEV "mkdir -p ~/${CI_PROJECT_NAME}"
    - rsync -avz --delete ./docker-compose.yml $DEPLOY_USER_DEV@$DEPLOY_SERVER_DEV:~/${CI_PROJECT_NAME}/docker-compose.yml
    - rsync -avz --delete ./.env $DEPLOY_USER_DEV@$DEPLOY_SERVER_DEV:~/${CI_PROJECT_NAME}/.env
    - ssh $DEPLOY_USER_DEV@$DEPLOY_SERVER_DEV "cd ~/${CI_PROJECT_NAME} && docker compose down && docker compose pull && docker compose up -d"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

deploy_prod:
  stage: deploy
  image: docker:$DOCKER_VERSION
  tags:
    - docker
  before_script:
    - 'which rsync || ( apk add --no-cache rsync )'
    - 'which ssh-agent || ( apk add --no-cache openssh-client)'
    - 'which git || ( apk add --no-cache git)'
    - 'which envsubst || apk add --no-cache gettext'
    - 'which skopeo || apk add --no-cache skopeo'
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | base64 -d | tr -d '\r' | ssh-add - || echo "Failed to add SSH key"
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_SERVER_PROD >> ~/.ssh/known_hosts
    - cp .env.example .env
    - sed -i "s|^#\?ALLOWED_HOSTS=.*|ALLOWED_HOSTS=$DEPLOY_SERVER_PROD|" .env
    - sed -i "s|^#\?CSRF_TRUSTED_ORIGINS=.*|CSRF_TRUSTED_ORIGINS=https://$DEPLOY_SERVER_PROD|" .env
    - sed -i "s|^#\?GITHUB_REPO=.*|GITHUB_REPO=$GITHUB_REPO_BACKEND_STORAGE_PROD|" .env
    - sed -i "s|^#\?GITHUB_ACCESS_TOKEN=.*|GITHUB_ACCESS_TOKEN=$GITHUB_ACCESS_TOKEN_BACKEND_STORAGE_PROD|" .env
    - sed -i "s|^#\?DJANGO_SECRET_KEY=.*|DJANGO_SECRET_KEY=\"$DJANGO_SECRET_KEY_PROD\"|" .env
  script:
    # Only deploy if this is the latest tag
    - git fetch --tags
    - LATEST_TAG=$(git tag --list 'v*' | sort -V | tail -n 1)
    - echo "Latest tag is $LATEST_TAG, current tag is $CI_COMMIT_TAG"
    - |
      if [ "$CI_COMMIT_TAG" != "$LATEST_TAG" ]; then
        echo "Not the latest tag, skipping deployment."
        exit 0
      fi
    # Export the image as a tarball
    - export VERSION_TAG="$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG"
    - echo "Preparing image $VERSION_TAG"
    - |
      skopeo copy --dest-compress \
        --src-creds "$CI_DEPLOY_USER:$CI_DEPLOY_PASSWORD" \
        docker://$VERSION_TAG \
        docker-archive:image.tar.gz:$VERSION_TAG
    # Prepare docker-compose file with correct tag
    - export IMAGE_TAG="$CI_COMMIT_TAG"
    - envsubst < docker-compose-deploy-template.yml > docker-compose.yml
    # Transfer files to server
    - ssh $DEPLOY_USER_PROD@$DEPLOY_SERVER_PROD "mkdir -p ~/${CI_PROJECT_NAME}"
    - rsync -avz --delete ./docker-compose.yml $DEPLOY_USER_PROD@$DEPLOY_SERVER_PROD:~/${CI_PROJECT_NAME}/docker-compose.yml
    - rsync -avz --delete ./.env $DEPLOY_USER_PROD@$DEPLOY_SERVER_PROD:~/${CI_PROJECT_NAME}/.env
    - rsync -avz --delete ./image.tar.gz $DEPLOY_USER_PROD@$DEPLOY_SERVER_PROD:~/${CI_PROJECT_NAME}/image.tar.gz

    # Deploy on server
    - |
      ssh $DEPLOY_USER_PROD@$DEPLOY_SERVER_PROD "
        cd ~/${CI_PROJECT_NAME} && \
        docker load -i image.tar.gz && \
        docker compose down || true && \
        docker compose up -d --remove-orphans
      "
  dependencies:
    - build
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'

.healthcheck_template: &healthcheck_template
  image: curlimages/curl:8.7.1
  tags:
    - docker
  script:
    - |
      set -x
      echo "Waiting for health endpoint to become healthy at $HEALTHCHECK_URL ..."
      i=1
      while [ $i -le 12 ]; do
        RESPONSE=$(curl -sk "$HEALTHCHECK_URL")
        STATUS=$(echo "$RESPONSE" | grep -o '"status":"ok"' || true)
        if [ "$STATUS" = '"status":"ok"' ]; then
          echo "Health check passed!"
          exit 0
        fi
        echo "Health check not ready yet, retrying in 10s... ($i/12)"
        i=$((i+1))
        sleep 10
      done
      echo "Health check failed after 120s!"
      exit 1

healthcheck_dev:
  extends: .healthcheck_template
  stage: healthcheck
  variables:
    HEALTHCHECK_URL: "https://$DEPLOY_SERVER_DEV/api/v1/health/"
  needs:
    - job: deploy_dev
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'


healthcheck_prod:
  extends: .healthcheck_template
  stage: healthcheck
  variables:
    HEALTHCHECK_URL: "https://$DEPLOY_SERVER_PROD/api/v1/health/"
  needs:
    - job: deploy_prod
      optional: true
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/'
